<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Admin Panel</title>
<style>
  :root{
    /* Neutral ‚Üí Earth fallbacks; DB branding will override */
    --bg:#A68A64;   /* warm sand */
    --bg2:#B7B7A4;  /* sage gray */
    --card:#3D3A2E; /* deep olive */
    --text:#ECEBE4; /* parchment */
    --muted:#CFCBBF;
    --accent:#6B705C;
    --good:#2ECC71;
    --warn:#F1C40F;
    --bad:#E74C3C;
    --border:#D9D6CE;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(135deg,var(--bg),var(--bg2));color:var(--text);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{position:sticky;top:0;background:#0d1020cc;backdrop-filter:saturate(150%) blur(10px);border-bottom:1px solid var(--border);padding:12px 20px}
  header .brand{display:flex;gap:10px;align-items:center;font-weight:700;letter-spacing:.3px}
  header .brand img{height:22px}
  main{padding:24px;max-width:1200px;margin:0 auto}
  .grid{display:grid;gap:16px}
  .cards{grid-template-columns:repeat(4,minmax(0,1fr))}
  .card.section .card.section {
    margin-top: 12px;  /* space between nested cards */
  }

  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;box-shadow:0 10px 30px #0006}
  .card h3{margin:0 0 8px 0;font-size:14px;color:var(--muted)}
  .charts {
    grid-template-columns: repeat(3, 1fr);
  }
  @media (max-width: 900px) {
    .charts {
      grid-template-columns: 1fr; /* fallback to stacked on small screens */
    }
  }

  .kpi{padding:16px}
  .kpi .value{font-size:28px;font-weight:800}
  .good{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .section{padding:16px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid var(--border)}
  th{color:var(--muted);font-weight:600;text-align:left}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .split{display:grid;grid-template-columns:2fr 1fr;gap:16px}
  canvas{width:100%;height:160px}
  @media (max-width:900px){ .cards{grid-template-columns:repeat(2,minmax(0,1fr))} .split{grid-template-columns:1fr} }
  @media (max-width:520px){ .cards{grid-template-columns:1fr} }
  #forecastSparkline {
    width: 100%;
    height: 60px !important;  /* keep it short */
    max-height: 60px;
  }
  #metrics-log-card {
  max-height: 200px;       /* keeps the card from growing forever */
  overflow-y: auto;        /* adds a scroll bar if too tall */
  }
  #metrics-log-card h3 {
  position: sticky;      /* ‚úÖ sticks the header */
  top: 0;
  background: var(--card); /* match card bg so it doesn‚Äôt overlap text */
  padding: 8px 0;
  z-index: 1;
}

  #metrics-log {
    list-style: none;
    padding: 0;
    margin: 0;
    word-wrap: break-word;   /* breaks long words */
    white-space: normal;     /* allows wrapping */
  }

  #metrics-log li {
    padding: 4px 0;
    border-bottom: 1px solid var(--border);
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  }
  /* üîπ Scrollable X-axis */
  .chart-scroll {
    overflow-x: auto;     /* allows horizontal scroll */
    overflow-y: hidden;
    width: 100%;
  }

  /* üîπ Force chart wider than container */
  .chart-scroll canvas {
    min-width: 900px;     /* adjust based on how many points */
    height: 300px;        /* keep consistent height */
  }

  
  
/* Auth view toggling */
#login { display: block; }
#dashboard { display: none; }
body.authed #authwrap { display: none; }          /* no !important needed */
body.authed #login { display: none; }
body.authed #dashboard { display: grid; }         /* was block */




</style>
</head>
<body>
<header>
  <div class="brand">
    <img id="brand-logo" alt="" style="display:none">
    <span id="brand-text"></span>

    <a href="/pricing" 
       style="margin-left:auto; padding:6px 10px; border:1px solid var(--border); background:transparent; color:var(--text); border-radius:8px; cursor:pointer; text-decoration:none;">
      Pricing
    </a>

    <button id="logoutBtn" 
       style="margin-left:10px; padding:6px 10px; border:1px solid var(--border); background:transparent; color:var(--text); border-radius:8px; cursor:pointer; display:none">
      Logout
    </button>
  </div>
</header>

<!-- Fullscreen flex wrapper (only for login) -->
<div id="authwrap" style="min-height:100vh; display:flex; align-items:center; justify-content:center;">
  <!-- üîê Login panel (hidden when authed) -->
  <div id="login" style="width:100%; max-width:420px; background:var(--card); border:1px solid var(--border); border-radius:14px; box-shadow:0 10px 30px #0006; padding:20px">
    <h2 style="margin:0 0 12px 0">Admin Login</h2>
    <form id="loginForm" method="post" class="grid" style="gap:10px">
      <input type="email" id="email" name="email" autocomplete="username" placeholder="Email" required
             style="padding:10px; border-radius:8px; border:1px solid var(--border); background:#0003; color:var(--text)">
      <input type="password" id="password" name="password" autocomplete="current-password" placeholder="Password" required
             style="padding:10px; border-radius:8px; border:1px solid var(--border); background:#0003; color:var(--text)">
      <button type="submit" style="padding:10px; border-radius:8px; border:1px solid var(--border); background:var(--accent); color:#fff; cursor:pointer">
        Sign In
      </button>
    </form>
    <p id="loginError" style="color:var(--bad); margin-top:8px"></p>
  </div>
</div>

<!-- üìä Dashboard (hidden until authed) -->
<main id="dashboard" class="grid">
  <div id="premium-sections" style="display:none" data-tenant="" data-key=""></div>

  <!-- Usage Visuals -->
  <section class ="grid charts">
    <div class="card section">
      <h3>Token Breakdown</h3>
      <canvas id="tokenBreakdownChart"></canvas>
    </div>

    <div class="card section">
      <h3>Cost Breakdown</h3>
      <canvas id="costBreakdownChart"></canvas>
    </div>

    <div class="card section">
      <h3>Forecast</h3>
      <div class="card section"><h3>Projected Monthly Cost</h3><div id="forecastText" class="value mono">‚Äî</div>
      <canvas id="forecastSparkline"></canvas>
      </div>
      
        <div class="card section" id="usage-card"><h3>Usage</h3>
          <div class="grid" style="grid-template-columns:1fr 1fr;gap:8px">
            <div>Period</div><div id="u-period" class="mono" style="text-align:right">‚Äî</div>
            <div>Tokens</div><div id="u-tokens" class="mono" style="text-align:right">‚Äî</div>
            <div>Cost</div><div id="u-cost" class="mono" style="text-align:right">‚Äî</div>
          </div>
        </div>
    </div>  
  </section>

  <div class="card section" id="conversationHistogramCard">
    <h3>Usage by Time of Day</h3>
    <canvas id="conversationHistogram"></canvas>
  </div>



  <!-- KPIs -->
  <section class="grid cards">
    <div class="card kpi"><h3>Status</h3><div id="kpi-status" class="value">‚Äî</div></div>
    <div class="card kpi"><h3>Requests (Today)</h3><div id="kpi-req" class="value">0</div></div>
    <div class="card kpi"><h3>Success Rate</h3><div id="kpi-sr" class="value">0%</div></div>
    <div class="card kpi"><h3>Avg Latency</h3><div id="kpi-lat" class="value">0ms</div></div>
  </section>

  <!-- Chart + Uptime/Usage -->
<section class="split">
  <div class="card section">
    <h3>Requests (last minute)</h3>
    <canvas id="spark"></canvas>
  </div>

  <!-- Remove the extra grid wrapper -->
  <section class="grid two-col">
    <div class="card section">
      <h3>Uptime</h3>
      <div id="uptime" class="value mono">‚Äî</div>
      <div id="health" style="color:var(--muted)">Checking‚Ä¶</div>
    </div>

    <div class="card section" id="metrics-log-card">
      <h3>Metrics Log</h3>
      <ul id="metrics-log"></ul>
    </div>
  </section>
</section>

  <!-- Errors -->
  <section class="card section" id="errors-card">
    <h3>Recent Errors</h3>
    <table>
      <thead><tr><th>Time</th><th>Message</th></tr></thead>
      <tbody id="errors-tbody"><tr><td colspan="2" style="color:var(--muted)">No errors</td></tr></tbody>
    </table>
  </section>

  <!-- Events -->
  <section class="card section" id="events-card">
    <h3>Recent Events</h3>
    <ul id="events-list"></ul>
  </section>
</main>


<footer style="padding:12px 20px;color:var(--muted)">
  <span id="brand-footer"></span>
</footer>




<script>

  // strip accidental creds from the URL if JS ever fell back to GET
(() => {
  const u = new URL(location.href);
  let touched = false;
  ['email','password'].forEach(k => { if (u.searchParams.has(k)) { u.searchParams.delete(k); touched = true; }});
  if (touched) history.replaceState(null, '', u.pathname + (u.searchParams.toString() ? `?${u.searchParams}` : ''));
})();

const $ = id => document.getElementById(id);
const fmt = ts => new Date(ts).toLocaleString();
const esc = s => String(s ?? '')
  .replace(/&/g,'&amp;').replace(/</g,'&lt;')
  .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
  .replace(/'/g,'&#39;');

let TENANT = "default"; // will be set after login

// üëá Session / auth UI helpers
function show(view){
  const login    = $('login');
  const dash     = $('dashboard');
  const btn      = $('logoutBtn');
  const authwrap = $('authwrap');

  const authed = (view === 'dashboard');

  document.body.classList.toggle('authed', authed);

  if (authwrap) authwrap.style.display = authed ? 'none'  : 'flex';
  if (login)    login.style.display    = authed ? 'none'  : 'block';
  if (dash)     dash.style.display     = authed ? 'grid'  : 'none';
  if (btn)      btn.style.display      = authed ? ''      : 'none';

  if (!authed) {
    setTimeout(() => $('email')?.focus(), 0);

    const err = $('loginError');
    if (err) err.textContent = '';

    const pwd = $('password');
    if (pwd) pwd.value = '';

    const form = $('loginForm');
    if (form) form.reset();
  }
}


// üîê Check active session
async function checkSession(){
  try {
    const r = await fetch('/api/me', { credentials: 'include' });
    if (r.ok) {
      const user = await r.json();
      TENANT = user.tenantId;   // ‚úÖ tenant from session
      show('dashboard');
      return true;
    }
  } catch(e) {}
  show('login');
  return false;
}

// üîê Login submit
document.addEventListener('DOMContentLoaded', () => {
  const form = $('loginForm');
  if (!form) return;

  // Utility to ensure a tenant picker exists (creates one if needed)
  async function ensureTenantPicker(tenants = []) {
    let pick = document.getElementById('tenantHint');
    if (pick) return pick;

    if (!Array.isArray(tenants) || tenants.length === 0) return null;

    pick = document.createElement('select');
    pick.id = 'tenantHint';
    pick.name = 'tenantHint';
    pick.required = true;
    pick.style.cssText =
      'padding:10px;border-radius:8px;border:1px solid var(--border);background:#0003;color:var(--text)';

    const opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = 'Select tenant‚Ä¶';
    pick.appendChild(opt0);

    tenants.forEach(t => {
      const opt = document.createElement('option');
      opt.value = t.id; // or t.subdomain if your server expects that
      opt.textContent = t.name + (t.subdomain ? ` (${t.subdomain})` : '');
      pick.appendChild(opt);
    });

    const submitBtn = form.querySelector('button[type="submit"]');
    form.insertBefore(pick, submitBtn);

    return pick;
  }

  form.addEventListener('submit', async (e) => {
  e.preventDefault();
  $('loginError').textContent = '';

  const email = $('email').value.trim();
  const password = $('password').value;
  const hintEl = document.getElementById('tenantHint');
  const tenantHint = hintEl ? hintEl.value : '';

  const btn = form.querySelector('button[type="submit"]');
  btn.disabled = true;
  btn.textContent = 'Signing in...';

  try {
    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ email, password, tenantHint })
    });

    // rate-limit handling
    if (res.status === 429) {
      const err = await res.json().catch(() => ({}));
      $('loginError').textContent =
        err?.error === 'too_many_attempts'
          ? 'Too many failed attempts. Try again in a few minutes.'
          : 'You‚Äôre being rate limited. Please wait a moment and try again.';
      $('password').value = '';
      return;
    }

    if (res.ok) {
      // ‚úÖ hide login immediately so the panel swaps right away
      show('dashboard');

      // fetch tenant from the session
      try {
        const meRes = await fetch('/api/me', { credentials: 'include' });
        if (!meRes.ok) throw new Error('me_failed');
        const me = await meRes.json();
        TENANT = me?.tenantId || '';
      } catch {
        show('login');
        $('loginError').textContent = 'Session check failed. Please try again.';
        return;
      }

      // kick off dashboard work without blocking the UI
      setTimeout(bootDashboard, 0);
      return;
    }

    // non-OK (but not 429): show specific errors
    const err = await res.json().catch(() => ({}));
    if (err?.error === 'tenant_required') {
      await ensureTenantPicker(err.tenants || []);
      $('loginError').textContent = 'Please select a tenant and sign in again.';
    } else {
      $('loginError').textContent = 'Invalid email or password.';
    }
    $('password').value = '';

  } catch (err) {
    $('loginError').textContent = 'Network error ‚Äî please try again.';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Sign In';
  }
});


  const logout = $('logoutBtn');
  if (logout) {
    logout.addEventListener('click', async () => {
      await fetch('/api/logout', { method: 'POST', credentials: 'include' });
      location.reload();
    });
  }
});
// Helper: call APIs (uses session cookie + tenant context)
function api(path, opts = {}) {
  const url = new URL(path, location.origin);

  // Only attach tenant if we already know it
  if (TENANT) {
    url.searchParams.set('tenant', TENANT);
  }

  return fetch(url, {
    ...opts,
    credentials: 'include'
  }).then(async (r) => {
    if (r.status === 401) {
      show('login');
      throw new Error('auth_required');
    }
    if (r.status === 429) {
      // Optional: show a small banner or console log
      console.warn('Rate limited. Backing off.');
      throw new Error('rate_limited');
    }
    return r;
  });

}


async function loadPremiumModule(cfg) {
  try {
    const config = cfg || window.CONFIG;
    if (!config?.features?.premium) return; // nothing to do

    const el = document.getElementById('premium-sections');
    if (el) {
      el.dataset.tenant = TENANT || 'default';
      el.dataset.key = config.publicKey || '';
      el.style.display = '';
    }
    const s = document.createElement('script');
    s.src = '/static/premium.js?v=' + Date.now();
    document.body.appendChild(s);
  } catch (e) {
    console.warn('Premium loader failed:', e.message);
  }
}

// -------------- Brand loader (config.json) --------------
// Branding from /api/portal/config (cookie auth)
window.CONFIG = null;

async function loadBranding(){
  const r = await fetch('/api/portal/config', { credentials: 'include' });
  if (!r.ok) throw new Error('branding load failed: ' + r.status);
  const cfg = await r.json();
  window.CONFIG = cfg;

  const name   = cfg.brandName || 'Brand';
  const portal = 'Client Portal';
  const templ  = cfg.titleTemplate || '{{brand}} ¬∑ {{portal}}';
  const render = s => s.replaceAll('{{brand}}', name).replaceAll('{{portal}}', portal);

  document.title = render(templ);
  $('brand-text').textContent = render(templ);

  const footerEl = $('brand-footer');
  if (footerEl) footerEl.textContent = cfg.footerText || render(templ);

  if (cfg.logo) {
    const img = $('brand-logo');
    img.src = cfg.logo;
    img.style.display = '';
    img.alt = name;
  }

  // Apply colors to CSS vars
  const c = cfg.colors || {};
  const set = (k,v)=> v!=null && document.documentElement.style.setProperty('--'+k, v);
  set('bg', c.bg);
  set('bg2', c.bg2);
  set('card', c.card);
  set('text', c.text);
  set('muted', c.muted);
  set('accent', c.accent);
  set('good', c.good);
  set('warn', c.warn);
  set('bad', c.bad);
  set('border', c.border);

  const angle = Number(cfg.gradientAngle) || 135;
  document.body.style.background = `linear-gradient(${angle}deg, var(--bg), var(--bg2))`;

  // Hide sections if features are disabled
  const feat = cfg.features || {};
  if (feat.usage === false)  $('usage-card').style.display = 'none';
  if (feat.errors === false) $('errors-card').style.display = 'none';
  if (feat.events === false) $('events-card').style.display = 'none';

  return cfg;
}


// -------------- Tiny sparkline --------------
const spark = document.getElementById('spark');
const ctx = spark.getContext('2d');
let series = Array.from({length:60}, ()=>0);
function drawSpark(){
  const w=spark.clientWidth||300, h=spark.clientHeight||160;
  spark.width=w*2; spark.height=h*2; ctx.setTransform(2,0,0,2,0,0);
  ctx.clearRect(0,0,w,h);
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#6ea8fe';
  ctx.lineWidth=2; ctx.beginPath();
  const max = Math.max(1, ...series);
  series.forEach((v,i)=> {
    const x = (i/(series.length-1))*w;
    const y = h - (v/max)*h;
    i?ctx.lineTo(x,y):ctx.moveTo(x,y);
  });
  ctx.stroke();
}

// ---------- Event formatter ----------

function formatEvent(ev){
  const role = (ev.role || '').toString();
  const color = role === "user" ? "var(--good)" : role === "ai" ? "var(--accent)" : "var(--muted)";
  return `
    <li style="margin:4px 0;">
      <span style="font-weight:bold;color:${color}">[${esc(role.toUpperCase())}]</span>
      <span style="color:${color};opacity:0.8"> ${fmt(ev.at)}</span>
      <div style="margin-left:12px;color:${color};font-family:ui-monospace;">
        ${esc(ev.message)}
      </div>
    </li>`;
}



// -------------- Data loader --------------
async function loadData() {
  // small helper: call api() -> JSON with status & ok flags
const fetchJSON = async (path) => {
    try {
      const res = await api(path);
      const data = await res.json().catch(() => null);
      return { ok: res.ok, status: res.status, data };
    } catch (e) {
      if (e?.message === 'auth_required') throw e;
      if (e?.message === 'rate_limited') {
        return { ok: false, status: 429, data: null, error: e };
      }
      return { ok: false, status: 0, data: null, error: e };
    }
  };


  try {
    const [mRes, errsRes, evsRes, healthRes] = await Promise.all([
      fetchJSON('/api/portal/metrics'),
      fetchJSON('/api/portal/errors'),
      fetchJSON('/api/portal/events'),
      fetchJSON('/api/portal/health'),
    ]);

    // ----- Health / status -----
    const m = mRes.ok && mRes.data ? mRes.data : {};
    const healthOK = !!(healthRes.ok && healthRes.data && healthRes.data.ok);

    const statusText = (m.status || 'ok').toUpperCase();
    const statusClass =
      statusText === 'OK' ? 'good' :
      statusText === 'DEGRADED' ? 'warn' : 'bad';

    $('kpi-status').textContent = mRes.status === 429 ? 'RATE LIMITED' : statusText;
    $('kpi-status').className = 'value ' + (mRes.status === 429 ? 'warn' : statusClass);

    $('health').textContent =
      mRes.status === 429 ? 'Rate limited' :
      healthOK ? 'Healthy' : 'Unreachable';

    // ----- Top KPIs -----
    $('kpi-req').textContent = m.requestsToday ?? 0;
    $('kpi-sr').textContent  = ((m.successRate ?? 0)).toString() + '%';
    $('kpi-lat').textContent = ((m.avgLatencyMs ?? 0)).toString() + 'ms';

    const up = m.uptimeSec ?? 0;
    $('uptime').textContent =
      Math.floor(up / 3600) + 'h ' + Math.floor((up % 3600) / 60) + 'm';

    // ----- Usage summary card -----
    const usage = m.usage || null;
    $('u-period').textContent = usage?.period ?? '‚Äî';

    const pt = usage?.prompt_tokens ?? 0;
    const ct = usage?.completion_tokens ?? 0;
    const cached = usage?.cached_tokens ?? 0;

    $('u-tokens').textContent = (pt + ct + cached).toLocaleString();
    $('u-cost').textContent =
      typeof usage?.costUSD === 'number' ? ('$' + usage.costUSD.toFixed(6)) : '‚Äî';

    // ----- Errors table -----
    const errs = Array.isArray(errsRes.data) ? errsRes.data : [];
    $('errors-tbody').innerHTML =
      errs.map(e =>
        `<tr><td>${fmt(e.at)}</td><td class="mono">${esc(e.message)}</td></tr>`
      ).join('') ||
      '<tr><td colspan="2" style="color:var(--muted)">No recent errors</td></tr>';

    // ----- Events list -----
    const evs = Array.isArray(evsRes.data) ? evsRes.data : [];
    $('events-list').innerHTML =
      (evs.length ? evs.map(formatEvent).join('') : '') ||
      '<li style="color:var(--muted)">No recent events</li>';

    // ----- Metrics log (safe DOM ops; no innerHTML) -----
    const logRes = await fetchJSON('/api/portal/metrics-log');
    const ul = $('metrics-log');
    ul.textContent = '';
    const rows = Array.isArray(logRes.data) ? logRes.data : [];
    if (!rows.length) {
      const li = document.createElement('li');
      li.style.color = 'var(--muted)';
      li.textContent = 'No metrics logged';
      ul.appendChild(li);
    } else {
      rows.forEach(row => {
        const li = document.createElement('li');
        li.append(document.createTextNode(`[${row?.at ? fmt(row.at) : '‚Äî'}] `));
        const strong = document.createElement('strong');
        strong.textContent = row?.type ?? '';
        li.appendChild(strong);
        li.append(document.createTextNode(`: ${row?.value ?? ''}`));
        ul.appendChild(li);
      });
    }

    // ----- Sparkline -----
    const prev = window.__lastReqs || 0;
    const now = m.requestsToday || 0;
    series.push(Math.max(0, now - prev));
    series.shift();
    window.__lastReqs = now;
    drawSpark();

  } catch (err) {
    if (err?.message === 'auth_required') {
      // api() already showed the login view
      return;
    }
    console.error('‚ùå loadData failed:', err);
    // make the status visibly ‚Äúoffline‚Äù without throwing
    $('kpi-status').textContent = 'OFFLINE';
    $('kpi-status').className = 'value bad';
    $('health').textContent = 'Unreachable';
  }
}


</script>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
<script>
  // Register once, after Chart.js is loaded
const DepthShadow = {
  id: 'depthShadow',
  beforeDatasetDraw(chart, args, opts = {}) {
    const { color='rgba(0,0,0,.45)', blur=22, offsetX=0, offsetY=10 } = opts || {};
    const ctx = chart.ctx;
    ctx.save();
    ctx.shadowColor  = color;
    ctx.shadowBlur   = blur;
    ctx.shadowOffsetX= offsetX;
    ctx.shadowOffsetY= offsetY;
  },
  afterDatasetDraw(chart) {
    chart.ctx.restore();
  }
};
  Chart.register(DepthShadow);
</script>


<script>
Chart.defaults.color = getComputedStyle(document.documentElement).getPropertyValue('--text');
Chart.defaults.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border');
Chart.defaults.responsive = true;



let tokenChart, costChart, forecastChart, conversationChart;


// --- Forecast Helpers ---
function forecastUsage(history) {
  if (!history.length) return { tokens: 0, cost: 0, trend: "flat", dailyTotals: [] };

  const recent = history.slice(-7); // last 7 entries
  const dailyTotals = recent.map(h => (h.prompt_tokens||0) + (h.completion_tokens||0));

  // regression slope
  const n = dailyTotals.length;
  const x = [...Array(n).keys()];
  const meanX = x.reduce((a,b)=>a+b,0)/n;
  const meanY = dailyTotals.reduce((a,b)=>a+b,0)/n;

  let num=0, den=0;
  for (let i=0;i<n;i++){
    num += (x[i]-meanX)*(dailyTotals[i]-meanY);
    den += (x[i]-meanX)**2;
  }
  const slope = den ? num/den : 0;

  const tokensMonth = dailyTotals.reduce((a,b)=>a+b,0) * (30/n);
  const costMonth   = (tokensMonth/1000) * 0.002;

  return {
    tokens: Math.round(tokensMonth),
    cost: costMonth.toFixed(2),
    trend: slope>0 ? "increasing" : (slope<0 ? "decreasing" : "flat"),
    dailyTotals
  };
}

function updateForecast(history) {
  const forecast = forecastUsage(history);

  document.getElementById('forecastText').textContent =
    `PMC: $${forecast.cost} (${forecast.trend} trend)`;

  if (!forecastChart) {
    forecastChart = new Chart(document.getElementById('forecastSparkline'), {
      type: 'line',
      data: {
        labels: forecast.dailyTotals.map((_, i) => `Day ${i+1}`),
        datasets: [{
          data: forecast.dailyTotals,
          borderColor: '#2ecc71',
          backgroundColor: 'transparent',
          pointRadius: 0,
          tension: 0.3
        }]
      },
      options: {
        plugins: { legend: { display: false } },
        scales: {
          x: { display: false },
          y: { display: false }
        }
      }
    });
  } else {
    forecastChart.data.labels = forecast.dailyTotals.map((_, i) => `Day ${i+1}`);
    forecastChart.data.datasets[0].data = forecast.dailyTotals;
    forecastChart.update();
  }
}

// --- Time-of-Day Histogram ---
function drawConversationHistogram(history) {
  const hourlyBuckets = Array(24).fill(0).map(()=>({prompt:0,completion:0}));

  history.forEach(h => {
    const hour = new Date(h.at).getHours();
    hourlyBuckets[hour].prompt     += h.prompt_tokens || 0;
    hourlyBuckets[hour].completion += h.completion_tokens || 0;
  });

  const labels = [...Array(24).keys()].map(h => `${h}:00`);
  const promptData = hourlyBuckets.map(b => b.prompt);
  const completionData = hourlyBuckets.map(b => b.completion);

  if (!conversationChart) {
    // Create it the first time
    conversationChart = new Chart(document.getElementById('conversationHistogram'), {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { label: 'Prompt', data: promptData, backgroundColor: '#3498db' },
          { label: 'Completion', data: completionData, backgroundColor: '#2ecc71' }
        ]
      },
      options: {
        responsive: true,
        animation: { duration: 500 }, // smooth update instead of flicker
        scales: {
        x: { 
          stacked: true, 
          ticks: { color: '#e9ecf1' } 
        },
        y: { 
          stacked: true, 
          ticks: { 
            color: '#e9ecf1',
            stepSize: 200   // ‚úÖ increments of 200
          },
          beginAtZero: true,
          suggestedMax: 2000 // optional, controls top of axis (adjust as needed)
        }
        }
      }

    });
  } else {
    // Just update data and re-render
    conversationChart.data.labels = labels;
    conversationChart.data.datasets[0].data = promptData;
    conversationChart.data.datasets[1].data = completionData;
    conversationChart.update();
  }
}


// --- Main Loader ---

// Accepts many key variants and falls back to pricing or proportional split
function normalizeBreakdown(bd, current, pricing = {}) {
  bd = bd || {};
  const pick = (o, keys) => keys.reduce((v,k)=> v ?? (o ? o[k] : undefined), undefined);

  let promptUSD     = Number(pick(bd, ['promptUSD','prompt_usd','prompt'])) || 0;
  let completionUSD = Number(pick(bd, ['completionUSD','completion_usd','completion'])) || 0;
  let cachedUSD     = Number(pick(bd, ['cachedUSD','cached_usd','cached'])) || 0;

  const sum = promptUSD + completionUSD + cachedUSD;
  if (sum > 0) return { promptUSD, completionUSD, cachedUSD };

  const pt = Number(current?.prompt_tokens)     || 0;
  const ct = Number(current?.completion_tokens) || 0;
  const kt = Number(current?.cached_tokens)     || 0;

  // Optional: compute from per-1k pricing if you later include it in the API
  const pp = Number(pricing.promptPer1K);
  const cp = Number(pricing.completionPer1K);
  const kp = Number(pricing.cachedPer1K);
  if (Number.isFinite(pp) && Number.isFinite(cp) && Number.isFinite(kp)) {
    return {
      promptUSD:     (pt / 1000) * pp,
      completionUSD: (ct / 1000) * cp,
      cachedUSD:     (kt / 1000) * kp
    };
  }

  // Fallback: apportion total by token share
  const totalCost = Number(current?.costUSD) || 0;
  const totalTok  = pt + ct + kt;
  if (totalCost > 0 && totalTok > 0) {
    return {
      promptUSD:     totalCost * (pt / totalTok),
      completionUSD: totalCost * (ct / totalTok),
      cachedUSD:     totalCost * (kt / totalTok)
    };
  }

  return { promptUSD: 0, completionUSD: 0, cachedUSD: 0 };
}


// ---- Replace your entire loadUsageCharts() with this ----
async function loadUsageCharts() {
  try {
    const res = await api('/api/portal/usage');
    if (!res.ok) throw new Error('Usage API error: ' + res.status);

    const payload = await res.json().catch(() => ({}));
    const current = payload?.current || null;
    const history = Array.isArray(payload?.history) ? payload.history : [];

    const safeCurrent = {
      prompt_tokens:     current?.prompt_tokens ?? 0,
      completion_tokens: current?.completion_tokens ?? 0,
      cached_tokens:     current?.cached_tokens ?? 0,
      costUSD:           current?.costUSD ?? 0,
      breakdown:         current?.breakdown || null
    };

    // ----- Token Breakdown -----
    if (!tokenChart) {
      tokenChart = new Chart(document.getElementById('tokenBreakdownChart'), {
        type: 'pie',
        data: {
          labels: ['Prompt Tokens', 'Completion Tokens', 'Cached Tokens'],
          datasets: [{
            data: [0, 0, 0],
            backgroundColor: ['#3498db', '#2ecc71', '#f39c12']
          }]
        }
      });
    }

    // ensure labels/data always match three slices
    tokenChart.data.labels = ['Prompt Tokens', 'Completion Tokens', 'Cached Tokens'];
    tokenChart.data.datasets[0].data = [
      safeCurrent.prompt_tokens,
      safeCurrent.completion_tokens,
      safeCurrent.cached_tokens
    ];
    tokenChart.update();

    // ----- Time-of-day Histogram -----
    drawConversationHistogram(history);

    // ----- Cost Breakdown (resilient) -----
    {
      const { promptUSD, completionUSD, cachedUSD } = normalizeBreakdown(
        current?.breakdown,
        {
          prompt_tokens:     safeCurrent.prompt_tokens,
          completion_tokens: safeCurrent.completion_tokens,
          cached_tokens:     safeCurrent.cached_tokens,
          costUSD:           safeCurrent.costUSD
        }
        // , optional pricing object if you add it to the API later
      );

      if (!costChart) {
        costChart = new Chart(document.getElementById('costBreakdownChart'), {
          type: 'pie',
          data: {
            labels: ['Prompt $', 'Completion $', 'Cached $'],
            datasets: [{
              data: [0, 0, 0],
              backgroundColor: ['#3498db', '#2ecc71', '#f39c12']
            }]
          },
          options: {
            plugins: {
              tooltip: {
                callbacks: {
                  label: (ctx) => `${ctx.label}: $${Number(ctx.raw || 0).toFixed(4)}`
                }
              }
            }
          }
        });
      }

      costChart.data.datasets[0].data = [promptUSD, completionUSD, cachedUSD];
      costChart.update();
    }

    // ----- Forecast -----
    updateForecast(history);

  } catch (err) {
    if (err?.message === 'auth_required' || err?.message === 'rate_limited') return;
    console.error('‚ùå loadUsageCharts failed:', err);
  }
}
 async function bootDashboard () {
    const cfg = await loadBranding();
    show('dashboard');
    loadData();
    loadUsageCharts();
    await loadPremiumModule(cfg);
    // start polling
    if (!window.__pollingStarted) {
      setInterval(loadData, 5000);
      setInterval(loadUsageCharts, 10000);
      window.__pollingStarted = true;
    }
 }

// --- Kickoff ---
window.addEventListener('resize', drawSpark);

(async function start(){
  try {
    const authed = await checkSession();
    if (!authed) { show('login'); return; }
    await bootDashboard();   // avoids duplicate init + duplicate intervals
  } catch (err) {
    console.error('‚ùå Startup error:', err);
    show('login');
  }
})();

</script>

